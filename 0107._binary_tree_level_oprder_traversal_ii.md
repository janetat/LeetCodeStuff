# Navigation
- [Navigation](#navigation)
- [Links:](#links)
- [Solution 1 DFS，递归](#solution-1-dfs%e9%80%92%e5%bd%92)
- [Solution 2 DFS，迭代，利用Stack](#solution-2-dfs%e8%bf%ad%e4%bb%a3%e5%88%a9%e7%94%a8stack)
- [Solution 3 BFS，利用队列](#solution-3-bfs%e5%88%a9%e7%94%a8%e9%98%9f%e5%88%97)
- [总结](#%e6%80%bb%e7%bb%93)


# Links:
1. https://leetcode.com/problems/binary-tree-level-order-traversal-ii/
2. https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/


# Solution 1 DFS，递归
```python
class Solution(object):
    def levelOrderBottom(self, root):
        res = []
        self.dfs(root, 0, res)
        return res[::-1]

    def dfs(self, root, level, res):
        if root:    # 证明当前层有元素
            if len(res) == level:   # 添加容器
                res.append([])
            res[level].append(root.val)
            self.dfs(root.left, level+1, res)
            self.dfs(root.right, level+1, res)
```

# Solution 2 DFS，迭代，利用Stack
```python
class Solution(object):
    def levelOrderBottom(self, root):
        stack = [(root, 0)]
        res = []

        while stack:
            node, level = stack.pop()
            if node:
                if len(res) == level:
                    res.append([])
                res[level].append(node.val)
                stack.append((node.right, level+1)) # 因为是栈，所以left和right顺序要掉转。在栈中，使得当前层的left在right上面。
                stack.append((node.left, level+1))

        return res[::-1]
```

# Solution 3 BFS，利用队列
```python
class Solution(object):
    def levelOrderBottom(self, root):
        queue = collections.deque([(root, 0)])
        res = []

        while queue:
            node, level = queue.popleft()

            if node:
                if len(res) == level:
                    res.append([])
                res[level].append(node.val)
                queue.append((node.left, level+1))
                queue.append((node.right, level+1))

        return res[::-1]
```

# 总结
Solution1和2都是在DFS过程中构建答案。
实质上都是考二叉树的遍历。