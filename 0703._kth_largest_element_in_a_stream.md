# Navigation
- [Navigation](#navigation)
- [Links](#links)
- [Solution 1 二分插入](#solution-1-%e4%ba%8c%e5%88%86%e6%8f%92%e5%85%a5)
- [Solution 2 小根堆](#solution-2-%e5%b0%8f%e6%a0%b9%e5%a0%86)

# Links
1. https://leetcode.com/problems/kth-largest-element-in-a-stream/
2. https://leetcode-cn.com/problems/kth-largest-element-in-a-stream/


# Solution 1 二分插入
1. 先排序整体。
2. 每次add，用二分查找，然后插入。
3. 插入完是有序，利用切片返回第三大元素。
```python
import bisect


class KthLargest(object):

    def __init__(self, k, nums):
        self.k = k
        # timsort, 时间复杂度：n*log(n)，空间复杂度：O(n)
        self.num = sorted(nums)

    def add(self, val):
        """
            bisect.insort(*args, **kwargs):
            Insert x in a in sorted order.
            This is equivalent to a.insert(bisect.bisect_left(a, x, lo, hi), x) assuming that a is already sorted.
            Keep in mind that the O(log n) search is dominated by the slow O(n) insertion step.
        """
        bisect.insort(self.num, val)

        return self.num[-self.k]
```

# Solution 2 小根堆