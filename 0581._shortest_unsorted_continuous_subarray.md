# Navigation
- [Navigation](#navigation)
- [Links](#links)
- [Solution 1 排序后的列表与未排序的列表对比](#solution-1-%e6%8e%92%e5%ba%8f%e5%90%8e%e7%9a%84%e5%88%97%e8%a1%a8%e4%b8%8e%e6%9c%aa%e6%8e%92%e5%ba%8f%e7%9a%84%e5%88%97%e8%a1%a8%e5%af%b9%e6%af%94)

# Links
1. https://leetcode.com/problems/shortest-unsorted-continuous-subarray/
2. https://leetcode-cn.com/problems/shortest-unsorted-continuous-subarray/


# Solution 1 排序后的列表与未排序的列表对比
```
    时间复杂度：O(Nlog(N))。排序
    空间复杂度：O(N)
```
```python
class Solution:
    def findUnsortedSubarray(self, nums):
        sorted_nums = sorted(nums)

        # left = float('inf')
        left = len(nums)
        right = 0

        for i in range(len(nums)):
            if nums[i] != sorted_nums[i]:
                left = min(left, i)
                right = max(right, i)

        return right - left + 1 if right - left + 1 > 0 else 0

```
---
```python
# 从两端开始找
class Solution:
    def findUnsortedSubarray(self, nums):
        sorted_nums = sorted(nums)

        # left = float('inf')
        left = len(nums)
        right = 0

        for i in range(len(nums)):
            if nums[i] != sorted_nums[i]:
                left = i
                break

        for i in range(len(nums) - 1, 0, -1):
            if nums[i] != sorted_nums[i]:
                right = i
                break

        return right - left + 1 if right - left + 1 > 0 else 0
```