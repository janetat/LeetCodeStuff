# Navigation
- [Navigation](#navigation)
- [Links](#links)
- [Solution 1 暴力法](#solution-1-%e6%9a%b4%e5%8a%9b%e6%b3%95)

# Links
1. https://leetcode.com/problems/range-addition-ii/
2. https://leetcode-cn.com/problems/range-addition-ii/


# Solution 1 暴力法
1. 根据m, n创建目标数组。
2. 执行ops中所有的操作。
3. 计算count。

```
    时间复杂度： O(len(ops) * m * n)
    空间复杂度： O(m * n)
```
```python
from typing import List

class Solution:
    def maxCount(self, m: int, n: int, ops: List[List[int]]) -> int:
        # arr = [[0] * n] * m # 不要这样！有坑
        arr = [[0 for i in range(n)] for j in range(m)]

        for op in ops:
            for i in range(op[0]):
                for j in range(op[1]):
                    arr[i][j] += 1  # 将范围内的元素加一

        print(arr)
        count = 0   # 操作总是会影响到 (0,0)(0,0)，所以元素 arr[0][0] 总是最大的

        for i in range(m):
            for j in range(n):
                if arr[i][j] == arr[0][0]:
                    count += 1  # 数有多少个跟 arr[0][0]arr[0][0] 一样大的元素就是答案

        return count

```