# Navigation
- [Navigation](#navigation)
- [Links](#links)
- [Solution 1 BFS，队列，哈希表](#solution-1-bfs%e9%98%9f%e5%88%97%e5%93%88%e5%b8%8c%e8%a1%a8)

# Links
1. https://leetcode.com/problems/average-of-levels-in-binary-tree/
2. https://leetcode-cn.com/problems/average-of-levels-in-binary-tree/


# Solution 1 BFS，队列，哈希表
1. 定义一个队列，用于BFS。队列的成员为(node, height)这样的元组。
2. 定义一个hash table(dict)去存储{height: [node1, node2...]}。字典的名称为avg。 
3. 先将(root, 0)进队。
4. 当队列不为空，弹出当前的元组。获得当前的节点和其高度。根据height作为avg的键，添加当前节点到avg[height]的对应的列表当中。
5. 如有左右节点，例如(node.left, height + 1)，(node.right，height + 1)，则入队。
6. 队列为空，所有节点和高度的对应关系已经在avg中。
7. 计算出最终的结果。每一层公式为用当前高度的所有节点值 处以 当前高度(对应的列表长度)。

一句话：用BFS遍历节点，构建key为height，value为当前高度的所有节点组成的列表，的哈希表（字典）。然后用这个字典求出答案。

```python
from queue import deque


class Solution:
    def averageOfLevels(self, root: TreeNode) -> List[List[int]]:
        if not root:
            return

        q = deque([(root, 0)])
        avg = {}

        while q:
            node, height = q.popleft()

            if height in avg:
                avg[height].append(node.val)
            else:
                avg[height] = [node.val]

            if node.left:
                q.append((node.left, height + 1))
            if node.right:
                q.append((node.right, height + 1))

        result = [
            sum(avg[height]) / len(avg[height])
            for height in avg
        ]

        return result
```