# Navigation
- [Navigation](#navigation)
- [Links:](#links)
- [Solution 1 Python API](#solution-1-python-api)
- [Solution 2 双指针，相同方向](#solution-2-%e5%8f%8c%e6%8c%87%e9%92%88%e7%9b%b8%e5%90%8c%e6%96%b9%e5%90%91)
  - [交换](#%e4%ba%a4%e6%8d%a2)
  - [覆盖](#%e8%a6%86%e7%9b%96)
- [Solution 3 双指针，相反方向](#solution-3-%e5%8f%8c%e6%8c%87%e9%92%88%e7%9b%b8%e5%8f%8d%e6%96%b9%e5%90%91)
- [Summary](#summary)

# Links:
1. https://leetcode.com/problems/remove-element/
2. https://leetcode-cn.com/problems/remove-element/


# Solution 1 Python API
真正意义上的删除。但是由题目的描述得知，可以不用真正地删除。
```python
class Solution(object):
    def removeElement(self, nums, val):
        """
        :type nums: List[int]
        :type val: int
        :rtype: int
        """
        frequency = nums.count(val)

        for i in range(frequency):
            nums.remove(val)

        return len(nums)
```
---
```python
class Solution(object):
    def removeElement(self, nums, val):
        """
        :type nums: List[int]
        :type val: int
        :rtype: int
        """
        i = 0

        while i < len(nums):
            if val == nums[i]:
                nums.pop(i)
            else:
                i += 1

        return len(nums)

```
---
```python
class Solution(object):
    def removeElement(self, nums, val):
        """
        :type nums: List[int]
        :type val: int
        :rtype: int
        """
        while val in nums:
            nums.pop(nums.index(val))

        return len(nums)
```
---
```python
class Solution:
    def removeElement(self, nums, val): 
        while val in nums:
            nums.remove(val)

        return len(nums)
```

# Solution 2 双指针，相同方向
```
当nums[fast]与给定的val相等时，则fast继续递增以跳过该元素。
只要nums[fast] != val，就把nums[fast]复制到nums[slow]。
并且快慢指针同时递增。直到fast到达列表的末尾。

用慢指针逐步构建删除元素后的列表，可以用交换或者覆盖方式。
```

## 交换
```python
class Solution:
    def removeElement(self, nums, val):
        slow = 0

        for fast in range(len(nums)):
            if nums[fast] != val:
                nums[slow], nums[fast] = nums[fast], nums[slow]
                slow += 1

        return slow
```

## 覆盖
```python
class Solution:
    def removeElement(self, nums, val):
        slow = 0

        for fast in range(len(nums)):
            if nums[fast] != val:
                nums[slow] = nums[fast]
                slow += 1

        return slow                
```
```python
class Solution(object):
   def removeElement(self, nums, val):
        slow = 0
        for num in nums:
            if num != val:
                nums[slow] = num
                slow += 1
        return slow
```


# Solution 3 双指针，相反方向
一个从头向后扫，一个从尾向前扫，start指针把等于 val 的位置和end指针不等于 val 的位置交换。也就是说，start指针会在等于val的位置停下来，end指针会在不等于val的位置停下来。

```python
class Solution:
    def removeElement(self, nums, val):
        start = 0   
        length = len(nums)
        end = length - 1

        while start < end:
            while start < end and nums[start] != val:  
                start += 1  # 在等于val的位置停下
            while start < end and nums[end] == val:  
                end -= 1     # 在不等于val的位置停下
            nums[start], nums[end] = nums[end], nums[start]
            start += 1
            end -= 1

        result = 0
        for i in range(length):
            if nums[i] != val:
                result += 1
        return result
```

---
```python
class Solution:
    def removeElement(self, nums, val):
        start, end = 0, len(nums) - 1
        while start <= end:
            if nums[start] == val:
                nums[start], nums[end], end = nums[end], nums[start], end - 1
            else:
                start +=1
        return start

```

# Summary
Solution 2和3是在旧列表中逐步构建符合要求的列表。
和0026类似的思想。可以看0026的总结。