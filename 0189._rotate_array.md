# Navigation
- [Navigation](#navigation)
- [Links:](#links)
- [Solution 1 暴力法，超时](#solution-1-%e6%9a%b4%e5%8a%9b%e6%b3%95%e8%b6%85%e6%97%b6)
- [Solution 2 使用额外的数组](#solution-2-%e4%bd%bf%e7%94%a8%e9%a2%9d%e5%a4%96%e7%9a%84%e6%95%b0%e7%bb%84)

# Links:
1. https://leetcode.com/problems/rotate-array/
2. https://leetcode-cn.com/problems/rotate-array/


# Solution 1 暴力法，超时
旋转k次，每次旋转1个元素
```
时间复杂度：O(n * k)。每个元素移动1步，共n步，移动k次。
空间复杂度：O(1)
```
---
```python
class Solution:
    def rotate(self, nums, k):
        for _ in range(k):
            previous = nums[-1]

            for i in range(len(nums)): 
                temp = nums[i]
                nums[i] = previous
                previous = temp
```
---
```python
class Solution:
    def rotate(self, nums, k):
        for _ in range(k):
            previous = nums[-1]

            for i in range(len(nums)):
                nums[i], previous = previous, nums[i]
```

# Solution 2 使用额外的数组
临时列表temp_list。把原本列表下标为i的数字放到(i+k)%len(nums)的位置。然后把临时列表复制到原数组中。
```
时间复杂度：O(n)
空间复杂度：O(n)
```
---
```python
class Solution:
    def rotate(self, nums, k):
        temp_list = [0] * len(nums)

        for i in range(len(nums)):
            temp_list[(i + k) % len(nums)] = nums[i]

        nums[:] = temp_list
```
---
```python
class Solution:
    def rotate(self, nums, k):
        temp_list = [0] * len(nums)

        for i in range(len(nums)):
            temp_list[(i + k) % len(nums)] = nums[i]

        for i in range(len(nums)):
            nums[i] = temp_list[i]
```

